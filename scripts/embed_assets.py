#!/usr/bin/env python3
"""Generate a C++ source file containing embedded binary assets."""

from __future__ import annotations

import argparse
import pathlib
import textwrap
from typing import Iterable


def sanitize_symbol(path: pathlib.Path) -> str:
    """Return a C++ identifier derived from the relative path."""
    name = path.as_posix()
    sanitized = [
        ch.lower() if ch.isalnum() else "_"
        for ch in name
    ]
    symbol = "".join(sanitized)
    while "__" in symbol:
        symbol = symbol.replace("__", "_")
    if not symbol:
        raise ValueError(f"empty symbol for path {path}")
    if symbol[0].isdigit():
        symbol = f"_{symbol}"
    return symbol


def format_data(data: bytes, indent: str) -> str:
    """Format binary data as a comma-separated list of hex bytes."""
    if not data:
        return "{}"

    chunks: list[str] = []
    line: list[str] = []

    for index, byte in enumerate(data):
        line.append(f"0x{byte:02X}")
        if (index + 1) % 12 == 0:
            chunks.append(indent + ", ".join(line))
            line = []
    if line:
        chunks.append(indent + ", ".join(line))

    return "{\n" + ",\n".join(chunks) + "\n}" if chunks else "{}"


def generate_source(output: pathlib.Path, root: pathlib.Path, inputs: Iterable[pathlib.Path]) -> None:
    entries = []
    data_sections = []

    for path in inputs:
        relative = path.relative_to(root)
        if len(relative.parts) >= 2 and relative.parts[0] == "src" and relative.parts[1] == "shaders":
            logical_path = pathlib.Path(*relative.parts[1:])
        else:
            logical_path = relative

        symbol = sanitize_symbol(logical_path)
        data = path.read_bytes()
        formatted = format_data(data, "  ")

        data_sections.append(
            textwrap.dedent(
                f"""
                alignas(16) const unsigned char data_{symbol}[] = {formatted};
                """
            ).strip()
        )

        entries.append(
            f"  EmbeddedAsset{{\"{logical_path.as_posix()}\", data_{symbol}, sizeof(data_{symbol})}}"
        )

    data_block = "\n\n".join(data_sections)
    entries_block = ",\n".join(entries)

    source = textwrap.dedent(
        f"""// @generated by embed_assets.py; do not edit manually.
#include \"builder/embedded_assets.h\"

namespace embedded_assets {{
namespace detail {{
{data_block}

const EmbeddedAsset kAssets[] = {{
{entries_block}
}};

const std::size_t kAssetCount = {len(entries)};

}}  // namespace detail
}}  // namespace embedded_assets
"""
    ).strip() + "\n"

    output.write_text(source)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Embed assets into a C++ translation unit.")
    parser.add_argument("output", type=pathlib.Path, help="Destination .cpp file")
    parser.add_argument("root", type=pathlib.Path, help="Repository root for relative paths")
    parser.add_argument("inputs", nargs="+", type=pathlib.Path, help="Asset files to embed")
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    inputs = [path.resolve() for path in args.inputs]
    root = args.root.resolve()
    generate_source(args.output.resolve(), root, inputs)


if __name__ == "__main__":
    main()
